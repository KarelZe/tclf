{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trade Classification With Python","text":"<p>Documentation \u2712\ufe0f: https://karelze.github.io/tclf/</p> <p>Source Code \ud83d\udc0d: https://github.com/KarelZe/tclf</p> <p><code>tclf</code> is a <code>scikit-learn</code>-compatible implementation of trade classification algorithms to classify financial markets transactions into buyer- and seller-initiated trades.</p> <p>The key features are:</p> <ul> <li>Easy: Easy to use and learn.</li> <li>Sklearn-compatible: Compatible to the sklearn API. Use sklearn metrics and visualizations.</li> <li>Feature complete: Wide range of supported algorithms. Use the algorithms individually or stack them like LEGO blocks.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>python -m pip install tclf\n</code></pre>"},{"location":"#supported-algorithms","title":"Supported Algorithms","text":"<ul> <li>(Rev.) CLNV rule<sup>1</sup></li> <li>(Rev.) EMO rule<sup>2</sup></li> <li>(Rev.) LR algorithm<sup>6</sup></li> <li>(Rev.) Tick test<sup>5</sup></li> <li>Depth rule<sup>3</sup></li> <li>Quote rule<sup>4</sup></li> <li>Tradesize rule<sup>3</sup></li> </ul> <p>For a primer on trade classification rules visit the rules section \ud83c\udd95 in our docs.</p>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Let's start simple: classify all trades by the quote rule and all other trades, which cannot be classified by the quote rule, randomly.</p> <p>Create a <code>main.py</code> with: main.py<pre><code>import numpy as np\nimport pandas as pd\n\nfrom tclf.classical_classifier import ClassicalClassifier\n\nX = pd.DataFrame(\n    [\n        [1.5, 1, 3],\n        [2.5, 1, 3],\n        [1.5, 3, 1],\n        [2.5, 3, 1],\n        [1, np.nan, 1],\n        [3, np.nan, np.nan],\n    ],\n    columns=[\"trade_price\", \"bid_ex\", \"ask_ex\"],\n)\n\nclf = ClassicalClassifier(layers=[(\"quote\", \"ex\")], strategy=\"random\")\nclf.fit(X)\nprobs = clf.predict_proba(X)\n</code></pre> Run your script with <pre><code>$ python main.py\n</code></pre> In this example, input data is available as a pd.DataFrame with columns conforming to our naming conventions.</p> <p>The parameter <code>layers=[(\"quote\", \"ex\")]</code> sets the quote rule at the exchange level and <code>strategy=\"random\"</code> specifies the fallback strategy for unclassified trades.</p>"},{"location":"#advanced-example","title":"Advanced Example","text":"<p>Often it is desirable to classify both on exchange level data and nbbo data. Also, data might only be available as a numpy array. So let's extend the previous example by classifying using the quote rule at exchange level, then at nbbo and all other trades randomly.</p> <p>main.py<pre><code>import numpy as np\nfrom sklearn.metrics import accuracy_score\n\nfrom tclf.classical_classifier import ClassicalClassifier\n\nX = np.array(\n    [\n        [1.5, 1, 3, 2, 2.5],\n        [2.5, 1, 3, 1, 3],\n        [1.5, 3, 1, 1, 3],\n        [2.5, 3, 1, 1, 3],\n        [1, np.nan, 1, 1, 3],\n        [3, np.nan, np.nan, 1, 3],\n    ]\n)\ny_true = np.array([-1, 1, 1, -1, -1, 1])\nfeatures = [\"trade_price\", \"bid_ex\", \"ask_ex\", \"bid_best\", \"ask_best\"]\n\nclf = ClassicalClassifier(\n    layers=[(\"quote\", \"ex\"), (\"quote\", \"best\")], strategy=\"random\", features=features\n)\nclf.fit(X)\nacc = accuracy_score(y_true, clf.predict(X))\n</code></pre> In this example, input data is available as np.arrays with both exchange (<code>\"ex\"</code>) and nbbo data (<code>\"best\"</code>). We set the layers parameter to <code>layers=[(\"quote\", \"ex\"), (\"quote\", \"best\")]</code> to classify trades first on subset <code>\"ex\"</code> and remaining trades on subset <code>\"best\"</code>. Additionally, we have to set <code>ClassicalClassifier(..., features=features)</code> to pass column information to the classifier.</p> <p>Like before, column/feature names must follow our naming conventions.</p>"},{"location":"#other-examples","title":"Other Examples","text":"<p>For more practical examples, see our examples section.</p>"},{"location":"#development","title":"Development","text":"<p>We are using <code>pixi</code> as a dependency management and workflow tool.</p> <pre><code>pixi install\npixi run postinstall\npixi run test\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you are using the package in publications, please cite as:</p> <pre><code>@software{bilz_tclf_2023,\n    author = {Bilz, Markus},\n    license = {BSD 3},\n    month = jan,\n    title = {{tclf} -- trade classification with python},\n    url = {https://github.com/KarelZe/tclf},\n    version = {0.0.6},\n    year = {2024}\n}\n</code></pre>"},{"location":"#footnotes","title":"Footnotes","text":"<ol> <li> <p>Chakrabarty, B., Li, B., Nguyen, V., &amp; Van Ness, R. A. (2007). Trade classification algorithms for electronic communications network trades. Journal of Banking &amp; Finance, 31(12), 3806\u20133821. https://doi.org/10.1016/j.jbankfin.2007.03.003 \u21a9</p> </li> <li> <p>Ellis, K., Michaely, R., &amp; O\u2019Hara, M. (2000). The accuracy of trade classification rules: Evidence from nasdaq. The Journal of Financial and Quantitative Analysis, 35(4), 529\u2013551. https://doi.org/10.2307/2676254 \u21a9</p> </li> <li> <p>Grauer, C., Schuster, P., &amp; Uhrig-Homburg, M. (2023). Option trade classification. https://doi.org/10.2139/ssrn.4098475 \u21a9\u21a9</p> </li> <li> <p>Harris, L. (1989). A day-end transaction price anomaly. The Journal of Financial and Quantitative Analysis, 24(1), 29. https://doi.org/10.2307/2330746 \u21a9</p> </li> <li> <p>Hasbrouck, J. (2009). Trading costs and returns for U.s. Equities: Estimating effective costs from daily data. The Journal of Finance, 64(3), 1445\u20131477. https://doi.org/10.1111/j.1540-6261.2009.01469.x \u21a9</p> </li> <li> <p>Lee, C., &amp; Ready, M. J. (1991). Inferring trade direction from intraday data. The Journal of Finance, 46(2), 733\u2013746. https://doi.org/10.1111/j.1540-6261.1991.tb02683.x \u21a9</p> </li> </ol>"},{"location":"naming_conventions/","title":"Naming conventions","text":"<p>For <code>tclf</code> to work, we impose constraints on the column names. The following input is required by each rule. Data requirements are additive, if multiple rules are applied.</p> Rule Layer Name Columns No classification <code>(\"nan\",\"sub\")</code> None Tick test <code>(\"tick\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lag</code> Reverse tick Test <code>(\"rev_tick\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lead</code> Quote Rule <code>(\"quote\",\"sub\")</code> <code>trade_price</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> Lee-Ready Algorithm <code>(\"lr\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lag</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> EMO Algorithm <code>(\"emo\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lag</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> CLNV Rule <code>(\"clnv\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lag</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> Reverse Lee-Ready Algorithm <code>(\"rev_lr\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lead</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> Reverse EMO Algorithm <code>(\"rev_emo\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lead</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> Reverse CLNV Rule <code>(\"rev_clnv\",\"sub\")</code> <code>trade_price</code>, <code>price_{sub}_lead</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code> Depth rule <code>(\"depth\",\"sub\")</code> <code>trade_price</code>, <code>ask_{sub}</code>, <code>bid_{sub}</code>, <code>ask_size_{sub}</code>, <code>bid_size_{sub}</code> Trade size rule <code>(\"trade_size\",\"sub\")</code> <code>trade_size</code>, <code>ask_size_{sub}</code>, <code>bid_size_{sub}</code>"},{"location":"nan_handling/","title":"Handling of NaNs","text":"<p>We take care to treat <code>NaN</code> values correctly. If features relevant for classification like the trade price or quoted bid/ask prices are missing, no classification is performed and classification of the trade is deferred to the subsequent rule or fallback strategy.</p> <p>Alternatively, you can provide imputed data. See <code>sklearn.impute</code> for details.</p>"},{"location":"option_trade_classification/","title":"Option trade classification","text":""},{"location":"option_trade_classification/#setup-rules","title":"Setup Rules","text":"<p>This tutorial aims to reproduce plots from a working paper by Grauer et al. (2023)<sup>1</sup>, which achieves state-of-the-art performance in option trade classification. The authors recommend to classify option trades by:</p> <p>[...] our new trade size rule together with quote rules successively applied to NBBO and quotes on the trading venue. Quotes at the midpoint on both the NBBO and the exchange should be classified first with the depth rule and any remaining trades with the reverse tick test.</p> <p>There's a lot going on.\ud83e\udd75</p> <p>To match the author's description, we first set up <code>layers</code>. We use the <code>tclf</code> implementation of the tradesize, quote, and depth rule, as well as reverse tick test. The subset named \"ex\" refers to exchange-specific data, \"best\" to the NBBO and \"all\" for inter-exchange level data. Identical to the paper, the reverse tick test is applied at the inter-exchange level, due to the devastating results of tick-based algorithms at the exchange level. The authors perform random classification on unclassified trades, hence we choose <code>strategy=\"random\"</code>. <pre><code>from tclf.classical_classifier import ClassicalClassifier\n\nlayers = [\n    (\"trade_size\", \"ex\"),\n    (\"quote\", \"best\"),\n    (\"quote\", \"ex\"),\n    (\"depth\", \"best\"),\n    (\"depth\", \"ex\"),\n    (\"rev_tick\", \"all\"),\n]\nclf = ClassicalClassifier(layers=layers, strategy=\"random\")\n</code></pre></p>"},{"location":"option_trade_classification/#prepare-dataset","title":"Prepare Dataset","text":"<p>Next, we need to load a dataset of option trades. I chose one, which was recorded at the ISE and used in the paper to evaluate the trade classification rules. I access it from a google cloud bucket and load it into a pandas dataframe <code>X</code>.</p> <p><pre><code>import gcsfs\nimport pandas as pd\n\nfs = gcsfs.GCSFileSystem()\n\ngcs_loc = fs.glob(\n        \"gs://tclf/bucket_name/dir_name/*\"\n)\nX = pd.read_parquet(gcs_loc, engine=\"pyarrow\", filesystem=fs)\n</code></pre> Unfortunately, the dataset does not yet follow the naming conventions and is missing columns required by <code>tclf</code>. We take care of this next.\ud83d\ude05</p> <pre><code>clf.fit(X)\n&gt;&gt;&gt; ValueError: Expected to find columns: ['ask_best', 'ask_size_best', 'bid_best', 'bid_size_best', 'trade_price', 'trade_size']. Check the naming/presence of columns. See: https://karelze.github.io/tclf/naming_conventions/\n</code></pre> <p>The calculation of the depth rule requires the columns <code>ask_{subset}</code>, <code>bid_{subset}</code>, and <code>trade_price</code>, as well as <code>ask_size_{subset}</code>, <code>bid_size_{subset}</code> and <code>trade_size</code>. The columns <code>BEST_ASK</code>, <code>BEST_BID</code>, <code>TRADE_PRICE</code>, and <code>TRADE_SIZE</code> are renamed to match our naming conventions of <code>ask_{subset}</code>, <code>bid_{subset}</code>, <code>trade_price</code>, and <code>trade_size</code>.</p> <p>As there is no <code>{ask/bid}_size_best</code> at the NBBO level (<code>subset=\"best\"</code>), I copy the columns from the trading venue. This allows us to mimic the author's decision to filter for mid-spread at the NBBO level, but classify by the trade size relative to the ask/bid size at the exchange.</p> <p>We save the true label <code>y_true</code> and the timestamp of the trade <code>QUOTE_DATETIME</code> to a new dataframe, named <code>X_meta</code>, which we use for plotting. We remove these columns from the original dataframe.</p> <pre><code>X = X.rename(\n    {\n        \"TRADE_PRICE\": \"trade_price\",\n        \"TRADE_SIZE\": \"trade_size\",\n        \"BEST_ASK\": \"ask_best\",\n        \"BEST_BID\": \"bid_best\",\n        \"buy_sell\": \"y_true\",\n    },\n    axis=1,\n)\n\nfeatures_meta = [\"QUOTE_DATETIME\", \"y_true\"]\nX_meta = X[features_meta]\nX = X.drop(columns=features_meta)\n\nX[[\"ask_size_best\", \"bid_size_best\"]] = X[[\"ask_size_ex\", \"bid_size_ex\"]]\n</code></pre>"},{"location":"option_trade_classification/#generate-results","title":"Generate Results","text":"<p>Next, we can simply pass the prepared dataframe <code>X</code> to the classifier and append the results to our dataframe <code>X_meta</code>.</p> <pre><code>X_meta[\"y_pred\"] = clf.fit(X).predict(X)\n</code></pre> <p>To estimate the accuracy over time, we group by date and estimate the accuracy for each group. We make use of <code>sklearn.metrics.accuracy_score</code>.</p> <pre><code>from sklearn.metrics import accuracy_score\n\ndf_plot = X_meta.groupby(X_meta.QUOTE_DATETIME.dt.date).apply(\n    lambda x: accuracy_score(x[\"y_true\"], x[\"y_pred\"]) * 100\n)\n</code></pre>"},{"location":"option_trade_classification/#plot-results","title":"Plot Results","text":"<p>We use <code>matplotlib</code> to match the plots from the paper as closely as possible.</p> <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.dates import DateFormatter\nfrom matplotlib.ticker import PercentFormatter\n\nplt.rcParams[\"font.family\"] = \"serif\"\n\nplt.figure(figsize=(9, 3))\nplt.grid(True, axis=\"y\")\n\n# line plot\nplt.plot(df_plot, color=\"tab:orange\", linewidth=1.5, label=\"ISE\")\n\n# y-axis + x-axis\nplt.ylim(0, 100)\nplt.ylabel(\"Overall success rate\")\nax = plt.gca()\nax.yaxis.set_major_formatter(PercentFormatter(100, decimals=0))\nax.xaxis.set_major_formatter(DateFormatter(\"%b-%y\"))\n\n# title + legend\nplt.title(\n    \"C: Performance of trade classification based on\\n trade size rule + depth rule + reverse LR (NBBO,exchange)\",\n    loc=\"left\",\n)\nplt.legend(loc=\"lower left\", frameon=False)\n\nplt.show()\n</code></pre> <p>Output:</p> <p></p> <p>Pretty close to the author's work. Just spanning a shorter period of time.\ud83d\ude42</p>"},{"location":"option_trade_classification/#footnotes","title":"Footnotes","text":"<ol> <li> <p>Grauer, C., Schuster, P., &amp; Uhrig-Homburg, M. (2023). Option trade classification. https://doi.org/10.2139/ssrn.4098475 \u21a9</p> </li> </ol>"},{"location":"reference/","title":"API reference","text":"<p>Welcome to the reference.</p> <p>             Bases: <code>ClassifierMixin</code>, <code>BaseEstimator</code></p> <p>ClassicalClassifier implements several trade classification rules.</p> <p>Including: Tick test, Reverse tick test, Quote rule, LR algorithm, EMO algorithm, CLNV algorithm, Trade size rule, Depth rule, and nan</p> <p>Parameters:</p> Name Type Description Default <code>classifier</code> <code>mixin (ClassifierMixin</code> <p>mixin for classifier functionality, such as <code>predict_proba()</code></p> required <code>base</code> <code>estimator (BaseEstimator</code> <p>base estimator for basic functionality, such as <code>transform()</code></p> required Source code in <code>src/tclf/classical_classifier.py</code> <pre><code>class ClassicalClassifier(ClassifierMixin, BaseEstimator):\n    \"\"\"ClassicalClassifier implements several trade classification rules.\n\n    Including:\n    Tick test,\n    Reverse tick test,\n    Quote rule,\n    LR algorithm,\n    EMO algorithm,\n    CLNV algorithm,\n    Trade size rule,\n    Depth rule,\n    and nan\n\n    Args:\n        classifier mixin (ClassifierMixin): mixin for classifier functionality, such as `predict_proba()`\n        base estimator (BaseEstimator): base estimator for basic functionality, such as `transform()`\n    \"\"\"\n\n    X_ = pd.DataFrame\n\n    def __init__(\n        self,\n        layers: list[\n            tuple[\n                ALLOWED_FUNC_LITERALS,\n                str,\n            ]\n        ]\n        | None = None,\n        *,\n        features: list[str] | None = None,\n        random_state: float | None = 42,\n        strategy: Literal[\"random\", \"const\"] = \"random\",\n    ):\n        \"\"\"Initialize a ClassicalClassifier.\n\n        Examples:\n            &gt;&gt;&gt; X = pd.DataFrame(\n            ... [\n            ...     [1.5, 1, 3],\n            ...     [2.5, 1, 3],\n            ...     [1.5, 3, 1],\n            ...     [2.5, 3, 1],\n            ...     [1, np.nan, 1],\n            ...     [3, np.nan, np.nan],\n            ... ],\n            ... columns=[\"trade_price\", \"bid_ex\", \"ask_ex\"],\n            ... )\n            &gt;&gt;&gt; clf = ClassicalClassifier(layers=[(\"quote\", \"ex\")], strategy=\"const\")\n            &gt;&gt;&gt; clf.fit(X)\n            ClassicalClassifier(layers=[('quote', 'ex')], strategy='const')\n            &gt;&gt;&gt; pred = clf.predict_proba(X)\n\n        Args:\n            layers (List[tuple[ALLOWED_FUNC_LITERALS, str]]): Layers of classical rule and subset name. Supported rules: \"tick\", \"rev_tick\", \"quote\", \"lr\", \"rev_lr\", \"emo\", \"rev_emo\", \"trade_size\", \"depth\", and \"nan\". Defaults to None, which results in classification by 'strategy' parameter.\n            features (List[str] | None, optional): List of feature names in order of columns. Required to match columns in feature matrix with label. Can be `None`, if `pd.DataFrame` is passed. Defaults to None.\n            random_state (float | None, optional): random seed. Defaults to 42.\n            strategy (Literal[&amp;quot;random&amp;quot;, &amp;quot;const&amp;quot;], optional): Strategy to fill unclassfied. Randomly with uniform probability or with constant 0. Defaults to &amp;quot;random&amp;quot;.\n        \"\"\"\n        self.layers = layers\n        self.random_state = random_state\n        self.features = features\n        self.strategy = strategy\n\n    def _more_tags(self) -&gt; dict[str, bool | dict[str, str]]:\n        \"\"\"Set tags for sklearn.\n\n        See: https://scikit-learn.org/stable/developers/develop.html#estimator-tags\n        \"\"\"\n        return {\n            \"allow_nan\": True,\n            \"binary_only\": True,\n            \"requires_y\": False,\n            \"poor_score\": True,\n            \"_xfail_checks\": {\n                \"check_classifiers_classes\": \"Disabled due to partly random classification.\",\n                \"check_classifiers_train\": \"No check, as unsupervised classifier.\",\n                \"check_classifiers_one_label\": \"Disabled due to partly random classification.\",\n                \"check_methods_subset_invariance\": \"No check, as unsupervised classifier.\",\n                \"check_methods_sample_order_invariance\": \"No check, as unsupervised classifier.\",\n                \"check_supervised_y_no_nan\": \"No check, as unsupervised classifier.\",\n                \"check_supervised_y_2d\": \"No check, as unsupervised classifier.\",\n                \"check_classifiers_regression_target\": \"No check, as unsupervised classifier.\",\n            },\n        }\n\n    def _tick(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) if its trade price is above (below) the closest different price of a previous trade.\n\n        Args:\n            subset (str): subset i.e., 'all' or 'ex'.\n\n        Returns:\n            npt.NDArray: result of tick rule. Can be np.NaN.\n        \"\"\"\n        return np.where(\n            self.X_[\"trade_price\"] &gt; self.X_[f\"price_{subset}_lag\"],\n            1,\n            np.where(\n                self.X_[\"trade_price\"] &lt; self.X_[f\"price_{subset}_lag\"], -1, np.nan\n            ),\n        )\n\n    def _rev_tick(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a sell (buy) if its trade price is below (above) the closest different price of a subsequent trade.\n\n        Args:\n            subset (str): subset i.e.,'all' or 'ex'.\n\n        Returns:\n            npt.NDArray: result of reverse tick rule. Can be np.NaN.\n        \"\"\"\n        return np.where(\n            self.X_[f\"price_{subset}_lead\"] &gt; self.X_[\"trade_price\"],\n            -1,\n            np.where(\n                self.X_[f\"price_{subset}_lead\"] &lt; self.X_[\"trade_price\"], 1, np.nan\n            ),\n        )\n\n    def _quote(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) if its trade price is above (below) the midpoint of the bid and ask spread. Trades executed at the midspread are not classified.\n\n        Args:\n            subset (str): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of quote rule. Can be np.NaN.\n        \"\"\"\n        mid = self._mid(subset)\n\n        return np.where(\n            self.X_[\"trade_price\"] &gt; mid,\n            1,\n            np.where(self.X_[\"trade_price\"] &lt; mid, -1, np.nan),\n        )\n\n    def _lr(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) if its price is above (below) the midpoint (quote rule), and use the tick test to classify midspread trades.\n\n        Adapted from Lee and Ready (1991).\n\n        Args:\n            subset (str): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.ndarray: result of the lee and ready algorithm with tick rule.\n            Can be np.NaN.\n        \"\"\"\n        q_r = self._quote(subset)\n        return np.where(~np.isnan(q_r), q_r, self._tick(subset))\n\n    def _rev_lr(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) if its price is above (below) the midpoint (quote rule), and use the reverse tick test to classify midspread trades.\n\n        Adapted from Lee and Ready (1991).\n\n        Args:\n            subset (str): subset i.e.,'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of the lee and ready algorithm with reverse tick\n            rule. Can be np.NaN.\n        \"\"\"\n        q_r = self._quote(subset)\n        return np.where(~np.isnan(q_r), q_r, self._rev_tick(subset))\n\n    def _mid(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Calculate the midpoint of the bid and ask spread.\n\n        Midpoint is calculated as the average of the bid and ask spread if the spread is positive. Otherwise, np.NaN is returned.\n\n        Args:\n            subset (str): subset i.e.,\n            'ex' or 'best'\n        Returns:\n            npt.NDArray: midpoints. Can be np.NaN.\n        \"\"\"\n        return np.where(\n            self.X_[f\"ask_{subset}\"] &gt;= self.X_[f\"bid_{subset}\"],\n            0.5 * (self.X_[f\"ask_{subset}\"] + self.X_[f\"bid_{subset}\"]),\n            np.nan,\n        )\n\n    def _is_at_ask_xor_bid(self, subset: str) -&gt; pd.Series:\n        \"\"\"Check if the trade price is at the ask xor bid.\n\n        Args:\n            subset (str): subset i.e.,\n            'ex' or 'best'.\n\n        Returns:\n            pd.Series: boolean series with result.\n        \"\"\"\n        at_ask = np.isclose(self.X_[\"trade_price\"], self.X_[f\"ask_{subset}\"], atol=1e-4)\n        at_bid = np.isclose(self.X_[\"trade_price\"], self.X_[f\"bid_{subset}\"], atol=1e-4)\n        return at_ask ^ at_bid\n\n    def _is_at_upper_xor_lower_quantile(\n        self, subset: str, quantiles: float = 0.3\n    ) -&gt; pd.Series:\n        \"\"\"Check if the trade price is at the ask xor bid.\n\n        Args:\n            subset (str): subset i.e., 'ex'.\n            quantiles (float, optional): percentage of quantiles. Defaults to 0.3.\n\n        Returns:\n            pd.Series: boolean series with result.\n        \"\"\"\n        in_upper = (\n            (1.0 - quantiles) * self.X_[f\"ask_{subset}\"]\n            + quantiles * self.X_[f\"bid_{subset}\"]\n            &lt;= self.X_[\"trade_price\"]\n        ) &amp; (self.X_[\"trade_price\"] &lt;= self.X_[f\"ask_{subset}\"])\n        in_lower = (self.X_[f\"bid_{subset}\"] &lt;= self.X_[\"trade_price\"]) &amp; (\n            self.X_[\"trade_price\"]\n            &lt;= quantiles * self.X_[f\"ask_{subset}\"]\n            + (1.0 - quantiles) * self.X_[f\"bid_{subset}\"]\n        )\n        return in_upper ^ in_lower\n\n    def _emo(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) if the trade takes place at the ask (bid) quote, and use the tick test to classify all other trades.\n\n        Adapted from Ellis et al. (2000).\n\n        Args:\n            subset (Literal[&amp;quot;ex&amp;quot;, &amp;quot;best&amp;quot;]): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of the emo algorithm with tick rule. Can be\n            np.NaN.\n        \"\"\"\n        return np.where(\n            self._is_at_ask_xor_bid(subset), self._quote(subset), self._tick(subset)\n        )\n\n    def _rev_emo(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) if the trade takes place at the ask (bid) quote, and use the reverse tick test to classify all other trades.\n\n        Adapted from Grauer et al. (2022).\n\n        Args:\n            subset (str): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of the emo algorithm with reverse tick rule.\n            Can be np.NaN.\n        \"\"\"\n        return np.where(\n            self._is_at_ask_xor_bid(subset), self._quote(subset), self._rev_tick(subset)\n        )\n\n    def _clnv(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade based on deciles of the bid and ask spread.\n\n        Spread is divided into ten deciles and trades are classified as follows:\n        - use quote rule for at ask until 30 % below ask (upper 3 deciles)\n        - use quote rule for at bid until 30 % above bid (lower 3 deciles)\n        - use tick rule for all other trades (\u00b12 deciles from midpoint; outside\n        bid or ask).\n\n        Adapted from Chakrabarty et al. (2007).\n\n        Args:\n            subset (str): subset i.e.,'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of the emo algorithm with tick rule. Can be\n            np.NaN.\n        \"\"\"\n        return np.where(\n            self._is_at_upper_xor_lower_quantile(subset),\n            self._quote(subset),\n            self._tick(subset),\n        )\n\n    def _rev_clnv(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade based on deciles of the bid and ask spread.\n\n        Spread is divided into ten deciles and trades are classified as follows:\n        - use quote rule for at ask until 30 % below ask (upper 3 deciles)\n        - use quote rule for at bid until 30 % above bid (lower 3 deciles)\n        - use reverse tick rule for all other trades (\u00b12 deciles from midpoint;\n        outside bid or ask).\n\n        Similar to extension of emo algorithm proposed Grauer et al. (2022).\n\n        Args:\n            subset (str): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of the emo algorithm with tick rule. Can be\n            np.NaN.\n        \"\"\"\n        return np.where(\n            self._is_at_upper_xor_lower_quantile(subset),\n            self._quote(subset),\n            self._rev_tick(subset),\n        )\n\n    def _trade_size(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify a trade as a buy (sell) the trade size matches exactly either the bid (ask) quote size.\n\n        Adapted from Grauer et al. (2022).\n\n        Args:\n            subset (str): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of the trade size rule. Can be np.NaN.\n        \"\"\"\n        bid_eq_ask = np.isclose(\n            self.X_[f\"ask_size_{subset}\"], self.X_[f\"bid_size_{subset}\"], atol=1e-4\n        )\n\n        ts_eq_bid = (\n            np.isclose(self.X_[\"trade_size\"], self.X_[f\"bid_size_{subset}\"], atol=1e-4)\n            &amp; ~bid_eq_ask\n        )\n        ts_eq_ask = (\n            np.isclose(self.X_[\"trade_size\"], self.X_[f\"ask_size_{subset}\"], atol=1e-4)\n            &amp; ~bid_eq_ask\n        )\n\n        return np.where(ts_eq_bid, 1, np.where(ts_eq_ask, -1, np.nan))\n\n    def _depth(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify midspread trades as buy (sell), if the ask size (bid size) exceeds the bid size (ask size).\n\n        Adapted from Grauer et al. (2022).\n\n        Args:\n            subset (str): subset i.e., 'ex' or 'best'.\n\n        Returns:\n            npt.NDArray: result of depth rule. Can be np.NaN.\n        \"\"\"\n        at_mid = np.isclose(self._mid(subset), self.X_[\"trade_price\"], atol=1e-4)\n\n        return np.where(\n            at_mid &amp; (self.X_[f\"ask_size_{subset}\"] &gt; self.X_[f\"bid_size_{subset}\"]),\n            1,\n            np.where(\n                at_mid\n                &amp; (self.X_[f\"ask_size_{subset}\"] &lt; self.X_[f\"bid_size_{subset}\"]),\n                -1,\n                np.nan,\n            ),\n        )\n\n    def _nan(self, subset: str) -&gt; npt.NDArray:\n        \"\"\"Classify nothing. Fast forward results from previous classifier.\n\n        Returns:\n            npt.NDArray: result of the trade size rule. Can be np.NaN.\n        \"\"\"\n        return np.full(shape=(self.X_.shape[0],), fill_value=np.nan)\n\n    def _validate_columns(self, missing_columns: list) -&gt; None:\n        \"\"\"Validate if all required columns are present.\n\n        Args:\n            missing_columns (list): list of missing columns.\n\n        Raises:\n            ValueError: columns missing in dataframe.\n        \"\"\"\n        columns = self.columns_ + missing_columns if self.columns_ else missing_columns\n        self.X_ = pd.DataFrame(np.zeros(shape=(1, len(columns))), columns=columns)\n        try:\n            self._predict()\n        except KeyError as e:\n            result = re.search(r\"'([^']+)'\", str(e))\n            if result:\n                add_missing = result.group(1)\n                if add_missing:\n                    missing_columns.append(add_missing)\n                    return self._validate_columns(missing_columns)\n        if missing_columns:\n            raise ValueError(\n                f\"Expected to find columns: {sorted(missing_columns)}. Check naming/presenence of columns. See: https://karelze.github.io/tclf/naming_conventions/\"\n            )\n        del self.X_\n        return None\n\n    def fit(\n        self,\n        X: MatrixLike,\n        y: ArrayLike | None = None,\n        sample_weight: npt.NDArray | None = None,\n    ) -&gt; ClassicalClassifier:\n        \"\"\"Fit the classifier.\n\n        Args:\n            X (MatrixLike): features\n            y (ArrayLike | None, optional):  ignored, present here for API consistency by convention.\n            sample_weight (npt.NDArray | None, optional):  Sample weights. Defaults to None.\n\n        Raises:\n            ValueError: Unknown subset e. g., 'ise'\n            ValueError: Unknown function string e. g., 'lee-ready'\n            ValueError: Multi output is not supported.\n\n        Returns:\n            ClassicalClassifier: Instance of itself.\n        \"\"\"\n        _check_sample_weight(sample_weight, X)\n\n        funcs = (\n            self._tick,\n            self._rev_tick,\n            self._quote,\n            self._lr,\n            self._rev_lr,\n            self._emo,\n            self._rev_emo,\n            self._clnv,\n            self._rev_clnv,\n            self._trade_size,\n            self._depth,\n            self._nan,\n        )\n\n        self.func_mapping_ = dict(zip(ALLOWED_FUNC_STR, funcs))\n\n        # create working copy to be altered and try to get columns from df\n        self.columns_ = self.features\n        if isinstance(X, pd.DataFrame):\n            self.columns_ = X.columns.tolist()\n\n        X = self._validate_data(\n            X,\n            y=\"no_validation\",\n            dtype=[np.float64, np.float32],\n            accept_sparse=False,\n            force_all_finite=False,\n        )\n\n        self.classes_ = np.array([-1, 1])\n\n        # if no features are provided or inferred, use default\n        if self.columns_ is None:\n            self.columns_ = [str(i) for i in range(X.shape[1])]\n\n        if len(self.columns_) &gt; 0 and X.shape[1] != len(self.columns_):\n            raise ValueError(\n                f\"Expected {len(self.columns_)} columns, got {X.shape[1]}.\"\n            )\n\n        self._layers = self.layers if self.layers is not None else []\n        for func_str, _ in self._layers:\n            if func_str not in ALLOWED_FUNC_STR:\n                raise ValueError(\n                    f\"Unknown function string: {func_str},\"\n                    f\"expected one of {ALLOWED_FUNC_STR}.\"\n                )\n\n        self._validate_columns([])\n        return self\n\n    def predict(self, X: MatrixLike) -&gt; npt.NDArray:\n        \"\"\"Perform classification on test vectors `X`.\n\n        Args:\n            X (MatrixLike): feature matrix.\n\n        Returns:\n            npt.NDArray: Predicted traget values for X.\n        \"\"\"\n        check_is_fitted(self)\n        X = self._validate_data(\n            X,\n            dtype=[np.float64, np.float32],\n            accept_sparse=False,\n            force_all_finite=False,\n        )\n\n        rs = check_random_state(self.random_state)\n\n        self.X_ = pd.DataFrame(data=X, columns=self.columns_)\n        pred = self._predict()\n\n        # fill NaNs randomly with -1 and 1 or with constant zero\n        mask = np.isnan(pred)\n        if self.strategy == \"random\":\n            pred[mask] = rs.choice(self.classes_, pred.shape)[mask]\n        else:\n            pred[mask] = np.zeros(pred.shape)[mask]\n\n        # reset self.X_ to avoid persisting it\n        del self.X_\n        return pred\n\n    def _predict(self) -&gt; npt.NDArray:\n        \"\"\"Predict with rule stack.\n\n        Returns:\n            npt.NDArray: prediction\n        \"\"\"\n        pred = np.full(shape=(self.X_.shape[0],), fill_value=np.nan)\n        for func_str, subset in self._layers:\n            func = self.func_mapping_[func_str]\n            pred = np.where(\n                np.isnan(pred),\n                func(subset=subset),\n                pred,\n            )\n        return pred\n\n    def predict_proba(self, X: MatrixLike) -&gt; npt.NDArray:\n        \"\"\"Predict class probabilities for X.\n\n        Probabilities are either 0 or 1 depending on the class.\n\n        For strategy 'constant' probabilities are (0.5,0.5) for unclassified classes.\n\n        Args:\n            X (MatrixLike): feature matrix\n\n        Returns:\n            npt.NDArray: probabilities\n        \"\"\"\n        # assign 0.5 to all classes. Required for strategy 'constant'.\n        prob = np.full((len(X), 2), 0.5)\n\n        # Class can be assumed to be -1 or 1 for strategy 'random'.\n        # Class might be zero though for strategy constant. Mask non-zeros.\n        preds = self.predict(X)\n        mask = np.flatnonzero(preds)\n\n        # get index of predicted class and one-hot encode it\n        indices = np.nonzero(preds[mask, None] == self.classes_[None, :])[1]\n        n_classes = np.max(self.classes_) + 1\n\n        # overwrite defaults with one-hot encoded classes.\n        # For strategy 'constant' probabilities are (0.5,0.5).\n        prob[mask] = np.identity(n_classes)[indices]\n        return prob\n</code></pre>"},{"location":"reference/#tclf.classical_classifier.ClassicalClassifier.__init__","title":"<code>__init__(layers=None, *, features=None, random_state=42, strategy='random')</code>","text":"<p>Initialize a ClassicalClassifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; X = pd.DataFrame(\n... [\n...     [1.5, 1, 3],\n...     [2.5, 1, 3],\n...     [1.5, 3, 1],\n...     [2.5, 3, 1],\n...     [1, np.nan, 1],\n...     [3, np.nan, np.nan],\n... ],\n... columns=[\"trade_price\", \"bid_ex\", \"ask_ex\"],\n... )\n&gt;&gt;&gt; clf = ClassicalClassifier(layers=[(\"quote\", \"ex\")], strategy=\"const\")\n&gt;&gt;&gt; clf.fit(X)\nClassicalClassifier(layers=[('quote', 'ex')], strategy='const')\n&gt;&gt;&gt; pred = clf.predict_proba(X)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>List[tuple[ALLOWED_FUNC_LITERALS, str]]</code> <p>Layers of classical rule and subset name. Supported rules: \"tick\", \"rev_tick\", \"quote\", \"lr\", \"rev_lr\", \"emo\", \"rev_emo\", \"trade_size\", \"depth\", and \"nan\". Defaults to None, which results in classification by 'strategy' parameter.</p> <code>None</code> <code>features</code> <code>List[str] | None</code> <p>List of feature names in order of columns. Required to match columns in feature matrix with label. Can be <code>None</code>, if <code>pd.DataFrame</code> is passed. Defaults to None.</p> <code>None</code> <code>random_state</code> <code>float | None</code> <p>random seed. Defaults to 42.</p> <code>42</code> <code>strategy</code> <code>Literal[&amp;quot;random&amp;quot;, &amp;quot;const&amp;quot;]</code> <p>Strategy to fill unclassfied. Randomly with uniform probability or with constant 0. Defaults to \"random\".</p> <code>'random'</code> Source code in <code>src/tclf/classical_classifier.py</code> <pre><code>def __init__(\n    self,\n    layers: list[\n        tuple[\n            ALLOWED_FUNC_LITERALS,\n            str,\n        ]\n    ]\n    | None = None,\n    *,\n    features: list[str] | None = None,\n    random_state: float | None = 42,\n    strategy: Literal[\"random\", \"const\"] = \"random\",\n):\n    \"\"\"Initialize a ClassicalClassifier.\n\n    Examples:\n        &gt;&gt;&gt; X = pd.DataFrame(\n        ... [\n        ...     [1.5, 1, 3],\n        ...     [2.5, 1, 3],\n        ...     [1.5, 3, 1],\n        ...     [2.5, 3, 1],\n        ...     [1, np.nan, 1],\n        ...     [3, np.nan, np.nan],\n        ... ],\n        ... columns=[\"trade_price\", \"bid_ex\", \"ask_ex\"],\n        ... )\n        &gt;&gt;&gt; clf = ClassicalClassifier(layers=[(\"quote\", \"ex\")], strategy=\"const\")\n        &gt;&gt;&gt; clf.fit(X)\n        ClassicalClassifier(layers=[('quote', 'ex')], strategy='const')\n        &gt;&gt;&gt; pred = clf.predict_proba(X)\n\n    Args:\n        layers (List[tuple[ALLOWED_FUNC_LITERALS, str]]): Layers of classical rule and subset name. Supported rules: \"tick\", \"rev_tick\", \"quote\", \"lr\", \"rev_lr\", \"emo\", \"rev_emo\", \"trade_size\", \"depth\", and \"nan\". Defaults to None, which results in classification by 'strategy' parameter.\n        features (List[str] | None, optional): List of feature names in order of columns. Required to match columns in feature matrix with label. Can be `None`, if `pd.DataFrame` is passed. Defaults to None.\n        random_state (float | None, optional): random seed. Defaults to 42.\n        strategy (Literal[&amp;quot;random&amp;quot;, &amp;quot;const&amp;quot;], optional): Strategy to fill unclassfied. Randomly with uniform probability or with constant 0. Defaults to &amp;quot;random&amp;quot;.\n    \"\"\"\n    self.layers = layers\n    self.random_state = random_state\n    self.features = features\n    self.strategy = strategy\n</code></pre>"},{"location":"reference/#tclf.classical_classifier.ClassicalClassifier.fit","title":"<code>fit(X, y=None, sample_weight=None)</code>","text":"<p>Fit the classifier.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>MatrixLike</code> <p>features</p> required <code>y</code> <code>ArrayLike | None</code> <p>ignored, present here for API consistency by convention.</p> <code>None</code> <code>sample_weight</code> <code>NDArray | None</code> <p>Sample weights. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unknown subset e. g., 'ise'</p> <code>ValueError</code> <p>Unknown function string e. g., 'lee-ready'</p> <code>ValueError</code> <p>Multi output is not supported.</p> <p>Returns:</p> Name Type Description <code>ClassicalClassifier</code> <code>ClassicalClassifier</code> <p>Instance of itself.</p> Source code in <code>src/tclf/classical_classifier.py</code> <pre><code>def fit(\n    self,\n    X: MatrixLike,\n    y: ArrayLike | None = None,\n    sample_weight: npt.NDArray | None = None,\n) -&gt; ClassicalClassifier:\n    \"\"\"Fit the classifier.\n\n    Args:\n        X (MatrixLike): features\n        y (ArrayLike | None, optional):  ignored, present here for API consistency by convention.\n        sample_weight (npt.NDArray | None, optional):  Sample weights. Defaults to None.\n\n    Raises:\n        ValueError: Unknown subset e. g., 'ise'\n        ValueError: Unknown function string e. g., 'lee-ready'\n        ValueError: Multi output is not supported.\n\n    Returns:\n        ClassicalClassifier: Instance of itself.\n    \"\"\"\n    _check_sample_weight(sample_weight, X)\n\n    funcs = (\n        self._tick,\n        self._rev_tick,\n        self._quote,\n        self._lr,\n        self._rev_lr,\n        self._emo,\n        self._rev_emo,\n        self._clnv,\n        self._rev_clnv,\n        self._trade_size,\n        self._depth,\n        self._nan,\n    )\n\n    self.func_mapping_ = dict(zip(ALLOWED_FUNC_STR, funcs))\n\n    # create working copy to be altered and try to get columns from df\n    self.columns_ = self.features\n    if isinstance(X, pd.DataFrame):\n        self.columns_ = X.columns.tolist()\n\n    X = self._validate_data(\n        X,\n        y=\"no_validation\",\n        dtype=[np.float64, np.float32],\n        accept_sparse=False,\n        force_all_finite=False,\n    )\n\n    self.classes_ = np.array([-1, 1])\n\n    # if no features are provided or inferred, use default\n    if self.columns_ is None:\n        self.columns_ = [str(i) for i in range(X.shape[1])]\n\n    if len(self.columns_) &gt; 0 and X.shape[1] != len(self.columns_):\n        raise ValueError(\n            f\"Expected {len(self.columns_)} columns, got {X.shape[1]}.\"\n        )\n\n    self._layers = self.layers if self.layers is not None else []\n    for func_str, _ in self._layers:\n        if func_str not in ALLOWED_FUNC_STR:\n            raise ValueError(\n                f\"Unknown function string: {func_str},\"\n                f\"expected one of {ALLOWED_FUNC_STR}.\"\n            )\n\n    self._validate_columns([])\n    return self\n</code></pre>"},{"location":"reference/#tclf.classical_classifier.ClassicalClassifier.predict","title":"<code>predict(X)</code>","text":"<p>Perform classification on test vectors <code>X</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>MatrixLike</code> <p>feature matrix.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>npt.NDArray: Predicted traget values for X.</p> Source code in <code>src/tclf/classical_classifier.py</code> <pre><code>def predict(self, X: MatrixLike) -&gt; npt.NDArray:\n    \"\"\"Perform classification on test vectors `X`.\n\n    Args:\n        X (MatrixLike): feature matrix.\n\n    Returns:\n        npt.NDArray: Predicted traget values for X.\n    \"\"\"\n    check_is_fitted(self)\n    X = self._validate_data(\n        X,\n        dtype=[np.float64, np.float32],\n        accept_sparse=False,\n        force_all_finite=False,\n    )\n\n    rs = check_random_state(self.random_state)\n\n    self.X_ = pd.DataFrame(data=X, columns=self.columns_)\n    pred = self._predict()\n\n    # fill NaNs randomly with -1 and 1 or with constant zero\n    mask = np.isnan(pred)\n    if self.strategy == \"random\":\n        pred[mask] = rs.choice(self.classes_, pred.shape)[mask]\n    else:\n        pred[mask] = np.zeros(pred.shape)[mask]\n\n    # reset self.X_ to avoid persisting it\n    del self.X_\n    return pred\n</code></pre>"},{"location":"reference/#tclf.classical_classifier.ClassicalClassifier.predict_proba","title":"<code>predict_proba(X)</code>","text":"<p>Predict class probabilities for X.</p> <p>Probabilities are either 0 or 1 depending on the class.</p> <p>For strategy 'constant' probabilities are (0.5,0.5) for unclassified classes.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>MatrixLike</code> <p>feature matrix</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>npt.NDArray: probabilities</p> Source code in <code>src/tclf/classical_classifier.py</code> <pre><code>def predict_proba(self, X: MatrixLike) -&gt; npt.NDArray:\n    \"\"\"Predict class probabilities for X.\n\n    Probabilities are either 0 or 1 depending on the class.\n\n    For strategy 'constant' probabilities are (0.5,0.5) for unclassified classes.\n\n    Args:\n        X (MatrixLike): feature matrix\n\n    Returns:\n        npt.NDArray: probabilities\n    \"\"\"\n    # assign 0.5 to all classes. Required for strategy 'constant'.\n    prob = np.full((len(X), 2), 0.5)\n\n    # Class can be assumed to be -1 or 1 for strategy 'random'.\n    # Class might be zero though for strategy constant. Mask non-zeros.\n    preds = self.predict(X)\n    mask = np.flatnonzero(preds)\n\n    # get index of predicted class and one-hot encode it\n    indices = np.nonzero(preds[mask, None] == self.classes_[None, :])[1]\n    n_classes = np.max(self.classes_) + 1\n\n    # overwrite defaults with one-hot encoded classes.\n    # For strategy 'constant' probabilities are (0.5,0.5).\n    prob[mask] = np.identity(n_classes)[indices]\n    return prob\n</code></pre>"},{"location":"rules/","title":"A Primer on Trade Classification Rules","text":"<p>The goal of trade classification algorithms is to identify the initiator of a trade. While definitions for the trade initiator differ in literature (cp. Lee &amp; Radhakrishna, 2000, pp. 94--97; Odders-White, 2000, p. 262)<sup>1</sup><sup>2</sup> the trade initiator is binary and either the buyer or the seller.</p> <p>As the trade initiator is frequently absent in datasets, it must be inferred using trade classification algorithms or other approaches. This article introduces basic rules for trade classification.</p>"},{"location":"rules/#notation","title":"Notation","text":"<p>We denote the predicted class by \\(y \\in \\mathcal{Y}\\) with \\(\\mathcal{Y}=\\{-1,1\\}\\), whereby \\(y=-1\\) is indicating a seller-initiated and \\(y=1\\) a buyer-initiated trade. We denote the sequence of trade prices of the \\(i\\)-th security by \\((P_{i,t})_{t=1}^{T}\\) and the corresponding ask at \\(t\\) by \\(A_{i,t}\\) and bid by \\(B_{i,t}\\). The midpoint of the bid-ask spread is denoted by \\(M_{i,t} = \\tfrac{1}{2}(B_{i,t} + A_{i,t})\\). Moreover, we denote the quoted size at the ask with \\(\\tilde{A}_{i,t}\\), \\(\\tilde{B}_{i,t}\\) of the bid, and \\(P_{i,t}\\) the trade price at \\(t\\) of the \\(i\\)-th security.</p> <p>For simplicity we assume an ideal data regime, where quote data is complete and spreads are positive.\ud83e\udd75</p>"},{"location":"rules/#basic-rules","title":"Basic Rules","text":"<p>This section presents basic classification rules, that may be used for trade classification independently or integrated into a hybrid algorithm.</p>"},{"location":"rules/#quote-rule","title":"Quote Rule","text":"<p>The quote rule classifies a trade by comparing the trade price against the corresponding quotes at the time of the trade. If the trade price is above the midpoint of the bid-ask spread, \\(M_{i,t}\\), the trade is classified as a buy and if it is below the midpoint, as a sell (Harris, 1989, p. 41)<sup>3</sup>.</p> <p>Thus, the classification rule on \\(\\mathcal{A} = \\left\\{(i, t) \\in \\mathbb{N}^2: P_{i,t} \\neq M_{i,t}\\right\\}\\) is given by:</p> \\[     \\operatorname{quote}\\colon \\mathcal{A} \\to \\mathcal{Y},\\quad     \\operatorname{quote}(i, t)=     \\begin{cases}         1,  &amp; \\mathrm{if}\\ P_{i, t}&gt;M_{i, t}  \\\\         -1, &amp; \\mathrm{if}\\ P_{i, t}&lt;M_{i, t}. \\\\     \\end{cases} \\] <p>The quote rule cannot classify trades at the midpoint of the quoted spread. A solution to overcome this limitation is to couple the quote rule with other approaches, as done in hybrid rules.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"quote\", \"subset\")])\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#tick-test","title":"Tick Test","text":"<p>A common alternative to the quote rule is the tick test. Based on the rationale that buys increase trade prices and sells lower them, the tick test classifies trades by the change in trade price. It was first applied in (Hasbrouck, 1988, p. 240; Holthausen, Leftwich, &amp; Mayers, 1987, p. 244)<sup>4</sup><sup>5</sup>.</p> <p>The tick test is defined as:</p> \\[     \\operatorname{tick}\\colon \\mathbb{N}^2 \\to \\mathcal{Y},\\quad     \\operatorname{tick}(i, t)=     \\begin{cases}         1,                           &amp; \\mathrm{if}\\ P_{i, t}&gt;P_{i, t-1} \\\\         -1,                          &amp; \\mathrm{if}\\ P_{i, t} &lt; P_{i, t-1}  \\\\         Y\\sim\\mathrm{Uniform}(\\mathcal{Y}), &amp; \\mathrm{if}\\ t=1 \\\\         \\operatorname{tick}(i, t-1), &amp; \\mathrm{else}.     \\end{cases} \\] <p>Considering the cases the trade price is higher than the previous price (uptick) the trade is classified as a buy. Reversely, if it is below the previous price (downtick), the trade is classified as a sell. If the price change is zero (zero tick), the signing uses the last price different from the current price (Lee &amp; Ready, 1991, p. 735)<sup>6</sup>. To end recursion at \\(t=1\\), we sign the trades randomly as buyer- or seller-initiated to simplify notation \ud83e\udd13.</p> <p>The tick rule can sign all trades as long as a last differing trade price exists, but the overall precision can be impacted by infrequent trading.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"tick\", \"subset\")], strategy=\"random\")\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#reverse-tick-test","title":"Reverse Tick Test","text":"<p>The reverse tick test is a variant of the tick test proposed in (Hasbrouck, 1988, p. 241)<sup>5</sup>. It is similar to the tick rule but classifies based on the next, distinguishable trade price.</p> \\[     \\operatorname{rtick} \\colon \\mathbb{N}^2 \\to \\mathcal{Y},\\quad     \\operatorname{rtick}(i, t)=     \\begin{cases}         1,                            &amp; \\mathrm{if}\\ P_{i, t} &gt; P_{i, t+1} \\\\         -1,                           &amp; \\mathrm{if}\\ P_{i, t} &lt; P_{i, t+1}            \\\\         Y\\sim\\mathrm{Uniform}(\\mathcal{Y}), &amp; \\mathrm{if}\\ t+1=T \\\\         \\operatorname{rtick}(i, t+1), &amp; \\mathrm{else}     \\end{cases} \\] <p>As denoted in the equation, the trade is classified as seller-initiated, if the next trade is on an uptick or a zero uptick, and classified as buyer-initiated for trades at a downtick or a zero downtick (Lee &amp; Ready, 1991, pp. 735--736)<sup>6</sup>.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"rev_tick\", \"subset\")], strategy=\"random\")\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#depth-rule","title":"Depth Rule","text":"<p>The depth rule gauges the trade initiator from the quoted size at the best bid and ask. Based on the observation that an exceeding bid or ask size relates to higher liquidity at one trade side, trades are classified as a buy (sell) for a larger ask (bid) size (Grauer, Schuster, &amp; Uhrig-Homburg, 2023, pp. 14--15)<sup>7</sup>. We set the domain as \\(\\mathcal{A} = \\left\\{(i, t) \\in \\mathbb{N}^2: P_{i,t} = M_{i,t} \\land \\tilde{A}_{i,t} \\neq \\tilde{B}_{i,t} \\right\\}\\). The depth rule is now calculated as:</p> \\[     \\operatorname{depth} \\colon \\mathcal{A} \\to \\mathcal{Y},\\quad     \\operatorname{depth}(i, t)=     \\begin{cases}         1,  &amp; \\mathrm{if}\\ \\tilde{A}_{i,t} &gt; \\tilde{B}_{i,t}. \\\\         -1, &amp; \\mathrm{if}\\ \\tilde{A}_{i,t} &lt; \\tilde{B}_{i,t}\\\\     \\end{cases} \\] <p>The depth rule classifies midspread trades only, if the ask size is different from the bid size, as the ratio between the ask and bid size is the sole criterion for inferring the trade's initiator. Due to these restrictive conditions in \\(\\mathcal{A}\\), the depth rule can sign only a fraction of all trades and must be best followed by other rules.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"depth\", \"subset\")])\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#trade-size-rule","title":"Trade Size Rule","text":"<p>The trade size rule classifies based on a match between the size of the trade \\(\\tilde{P}_{i, t}\\) and the quoted bid and ask sizes. The rationale is, that the market maker tries to fill the limit order of a customer, which results in the trade being executed at the contemporaneous bid or ask, with a trade size equaling the quoted size (Grauer, Schuster, &amp; Uhrig-Homburg, 2023)<sup>7</sup>. The trade size rule is defined on \\(\\mathcal{A} = \\left\\{(i, t) \\in \\mathbb{N}^2: \\tilde{P}_{i,t} = \\tilde{A}_{i,t} \\neq \\tilde{B}_{i,t} \\lor \\tilde{P}_{i,t} \\neq\\tilde{A}_{i,t} = \\tilde{B}_{i,t} \\right\\}\\) as:</p> \\[     \\operatorname{tsize} \\colon \\mathcal{A} \\to \\mathcal{Y},\\quad     \\operatorname{tsize}(i, t)=     \\begin{cases}         1,  &amp; \\mathrm{if}\\ \\tilde{P}_{i, t} = \\tilde{B}_{i, t} \\neq \\tilde{A}_{i, t}  \\\\         -1, &amp; \\mathrm{if}\\ \\tilde{P}_{i, t} = \\tilde{A}_{i, t} \\neq \\tilde{B}_{i, t}. \\\\     \\end{cases} \\] <p>When both the size of the ask and bid correspond with the trade size or the trade size does not match the quoted sizes, the result is ambiguous.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"trade_size\", \"subset\")])\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#hybrid-rules","title":"Hybrid Rules","text":"<p>The basic trade classification rules from basic rules can be combined into a hybrid algorithm to enforce universal applicability to all trades and improve the classification performance.</p> <p>Popular variants include the LR algorithm, the EMO rule, and the CLNV method. All three algorithms utilize the quote and tick rule to a varying extent. Basic rules are selected based on the proximity of the trade price to the quotes.</p> <p>As put forth by Grauer et al. (2023)<sup>7</sup>, basic or hybrid rules can be combined through stacking. This approach generalizes the aforementioned algorithms, as the applied rule is no longer dependent on the proximity to the quotes, but rather on the classifiability of the trade with the primary rules given by the domains and their ordering.</p>"},{"location":"rules/#lee-and-ready-algorithm","title":"Lee and Ready Algorithm","text":"<p>The LR algorithm (Lee &amp; Ready, 1991, p. 745)<sup>6</sup> combines the (reverse) tick test and quote rule into a single rule, which is derived from two observations. First, Lee and Ready (1991, pp. 735--745)<sup>6</sup> observe a higher precision of the quote rule over the tick rule, which makes it their preferred choice. Second, by the means of a simple model, the authors demonstrate that the tick test can correctly classify on average 85.4 % of all midspread trades if the model's assumptions of constant quotes between trades and the arrival of the market and standing orders following a Poisson process are met. Outside the model's tight assumptions, the expected accuracy of the tick test can be unmet.</p> <p>In combination, the algorithm primarily signs trades according to the quote rule. Trades at the midpoint of the spread, unclassifiable by the quote rule, are classified by the tick test. Overall:</p> \\[     \\operatorname{lr} \\colon \\mathbb{N}^2 \\to \\mathcal{Y},\\quad\\operatorname{lr}(i,t)=     \\begin{cases}         1,                         &amp; \\mathrm{if}\\ P_{i, t} &gt; M_{i, t} \\\\         -1,                        &amp; \\mathrm{if}\\ P_{i, t} &lt; M_{i, t} \\\\         \\operatorname{tick}(i, t), &amp; \\mathrm{else}.     \\end{cases} \\] <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"lr\", \"subset\")])\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#ellis-michaely-ohara-rule","title":"Ellis-Michaely-O'Hara Rule","text":"<p>Ellis et al. (2000, pp. 535--536)<sup>8</sup> examine the performance of the previous algorithms for stocks traded at NASDAQ. By analyzing miss-classified trades with regard to the proximity of the trade to the quotes, they observe, that the quote rule and by extension, the LR algorithm, perform particularly well at classifying trades executed at the bid and the ask price but trail the performance of the tick rule for trades inside or outside the spread (Ellis, Michaely, &amp; O'Hara, 2000, pp. 535--536)<sup>8</sup>. The authors combine these observations into a single rule, known as the EMO algorithm.</p> <p>The EMO algorithm extends the tick rule by classifying trades at the quotes using the quote rule, and all other trades with the tick test. Formally, the classification rule is given by:</p> \\[     \\operatorname{emo} \\colon \\mathbb{N}^2 \\to \\mathcal{Y}, \\quad     \\operatorname{emo}(i, t)=     \\begin{cases}         1,                         &amp; \\mathrm{if}\\ P_{i, t} = A_{i, t} \\\\         -1,                        &amp; \\mathrm{if}\\ P_{i, t} = B_{i, t} \\\\         \\operatorname{tick}(i, t), &amp; \\mathrm{else}.     \\end{cases} \\] <p>The EMO algorithm embeds both the quote and tick rule. As trades off the quotes are classified by the tick rule, the algorithm's overall success rate is dominated by the tick test assuming most trades are off-the-quotes.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"emo\", \"subset\")])\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#chakrabarty-li-nguyen-van-ness-method","title":"Chakrabarty-Li-Nguyen-Van-Ness Method","text":"<p>Like the previous two algorithms, the CLNV method (Chakrabarty, Li, Nguyen, &amp; Van Ness, 2007, pp. 3811--3812)<sup>9</sup>  is a hybrid of the quote and tick rule and extends the EMO rule by a differentiated treatment of trades inside the quotes, which are notoriously hard to classify. The authors segment the bid-ask spread into deciles (ten equal-width bins) and classify trades around the midpoint (fourth to seventh decile) by the tick rule and trades close or outside the quotes are categorized by the tick rule.</p> \\[     \\operatorname{clnv} \\colon \\mathbb{N}^2 \\to \\mathcal{Y}, \\quad     \\operatorname{clnv}(i, t)=     \\begin{cases}         1,                         &amp; \\mathrm{if}\\ P_{i, t} \\in \\left(\\frac{3}{10} B_{i,t} + \\frac{7}{10} A_{i,t}, A_{i, t}\\right] \\\\         -1,                        &amp; \\mathrm{if}\\ P_{i, t} \\in \\left[ B_{i,t}, \\frac{7}{10} B_{i,t} + \\frac{3}{10} A_{i,t}\\right) \\\\         \\operatorname{tick}(i, t), &amp; \\mathrm{else}     \\end{cases} \\] <p>It is derived from a performance comparison of the tick rule (EMO rule) against the quote rule (LR algorithm) on stock data, whereby the accuracy was assessed separately for each decile.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\nclf = ClassicalClassifier(layers=[(\"clnv\", \"subset\")])\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#stacked-rule","title":"Stacked Rule","text":"<p>The previous algorithms are static concerning the used base rules and their alignment. Combining arbitrary rules into a single algorithm requires a generic procedure. Grauer et al. (2023, p. 15)<sup>7</sup> combine basic and hybrid rules through stacking. In this setting, the trade traverses a stack of pre-defined rules until a rule can classify the trade or the end of the stack is reached. The classification is now dependent on the employed rules but also on their relative ordering.</p> <p>The most basic application is in the LR algorithm, combining \\(\\operatorname{quote}\\) and \\(\\operatorname{tick}\\). For a more complex example consider the hybrid rule consisting of \\(\\operatorname{tsize}_{\\mathrm{ex}}\\), \\(\\operatorname{quote}_{\\mathrm{nbbo}}\\), \\(\\operatorname{quote}_{\\mathrm{ex}}\\), \\(\\operatorname{depth}_{\\mathrm{nbbo}}\\), \\(\\operatorname{depth}_{\\mathrm{ex}}\\) and  \\(\\operatorname{rtick}_{\\mathrm{all}}\\) popularized in Grauer et al. (2023, p. 15)<sup>7</sup>.</p> <p>In practice, rules may be ordered greedily and new rules added if there are unclassified trades.</p> <p>Code <pre><code>from tclf.classical_classifier import ClassicalClassifier\n\nlayers = [\n    (\"trade_size\", \"ex\"),\n    (\"quote\", \"best\"),\n    (\"quote\", \"ex\"),\n    (\"depth\", \"best\"),\n    (\"depth\", \"ex\"),\n    (\"rev_tick\", \"all\"),\n]\nclf = ClassicalClassifier(layers=layers, strategy=\"random\")\nclf.fit(X)\n</code></pre></p>"},{"location":"rules/#footnotes","title":"Footnotes","text":"<ol> <li> <p>Lee, C., &amp; Radhakrishna, B. (2000). Inferring investor behavior: Evidence from TORQ data. Journal of Financial Markets, 3(2), 83\u2013111. https://doi.org/10.1016/S1386-4181(00)00002-1 \u21a9</p> </li> <li> <p>Odders-White, E. R. (2000). On the occurrence and consequences of inaccurate trade classification. Journal of Financial Markets, 3(3), 259\u2013286. https://doi.org/10.1016/S1386-4181(00)00006-9 \u21a9</p> </li> <li> <p>Harris, L. (1989). A day-end transaction price anomaly. The Journal of Financial and Quantitative Analysis, 24(1), 29. https://doi.org/10.2307/2330746 \u21a9</p> </li> <li> <p>Holthausen, R. W., Leftwich, R. W., &amp; Mayers, D. (1987). The effect of large block transactions on security prices: A cross-sectional analysis. Journal of Financial Economics, 19(2), 237\u2013267. https://doi.org/10.1016/0304-405X(87)90004-3 \u21a9</p> </li> <li> <p>Hasbrouck, J. (1988). Trades, quotes, inventories, and information. Journal of Financial Economics, 22(2), 229\u2013252. https://doi.org/10.1016/0304-405X(88)90070-0 \u21a9\u21a9</p> </li> <li> <p>Lee, C., &amp; Ready, M. J. (1991). Inferring trade direction from intraday data. The Journal of Finance, 46(2), 733\u2013746. https://doi.org/10.1111/j.1540-6261.1991.tb02683.x \u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Grauer, C., Schuster, P., &amp; Uhrig-Homburg, M. (2023). Option trade classification. https://doi.org/10.2139/ssrn.4098475 \u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Ellis, K., Michaely, R., &amp; O\u2019Hara, M. (2000). The accuracy of trade classification rules: Evidence from nasdaq. The Journal of Financial and Quantitative Analysis, 35(4), 529\u2013551. https://doi.org/10.2307/2676254 \u21a9\u21a9</p> </li> <li> <p>Chakrabarty, B., Li, B., Nguyen, V., &amp; Van Ness, R. A. (2007). Trade classification algorithms for electronic communications network trades. Journal of Banking   &amp; Finance, 31(12), 3806\u20133821. https://doi.org/10.1016/j.jbankfin.2007.03.003 \u21a9</p> </li> </ol>"}]}